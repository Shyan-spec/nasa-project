{"ast":null,"code":"// States\nconst ENTERED = 'entered';\nconst ENTERING = 'entering';\nconst EXITING = 'exiting';\nconst EXITED = 'exited'; // Actions\n\nconst ENTER_START = 'enterStart';\nconst ENTER_END = 'enterEnd';\nconst EXIT_START = 'exitStart';\nconst EXIT_END = 'exitEnd'; // Managers\n\nconst PARALLEL = 'parallel';\nconst SEQUENCE = 'sequence';\nconst STAGGER = 'stagger';\nconst ANIMATOR_DEFAULT_KEYS = {\n  ENTERED,\n  ENTERING,\n  EXITING,\n  EXITED,\n  ENTER_START,\n  ENTER_END,\n  EXIT_START,\n  EXIT_END,\n  PARALLEL,\n  SEQUENCE,\n  STAGGER\n};\n\nconst createAnimatorManagerParallel = () => {\n  const transitionChildren = children => {\n    children.forEach(child => child.send(ENTER_START));\n  };\n\n  return Object.freeze({\n    name: PARALLEL,\n    transitionChildren\n  });\n};\n\nconst createAnimatorManagerStagger = parent => {\n  let reservedUntilTime;\n\n  const transitionChildren = children => {\n    var _a;\n\n    const parentSettings = parent.control.getSettings();\n    const stagger = (((_a = parentSettings.duration) === null || _a === void 0 ? void 0 : _a.stagger) || 0) * 1000; // seconds to ms\n\n    const now = Date.now();\n    reservedUntilTime = reservedUntilTime !== undefined ? Math.max(reservedUntilTime, now) : now;\n    children.forEach(child => {\n      var _a;\n\n      const childSettings = child.control.getSettings();\n      const offset = (((_a = childSettings.duration) === null || _a === void 0 ? void 0 : _a.offset) || 0) * 1000; // seconds to ms\n\n      reservedUntilTime = reservedUntilTime + offset;\n      const delay = (reservedUntilTime - now) / 1000; // ms to seconds\n\n      reservedUntilTime = reservedUntilTime + stagger;\n      child.scheduler.start(delay, () => child.send(ENTER_START));\n    });\n  };\n\n  return Object.freeze({\n    name: STAGGER,\n    transitionChildren\n  });\n}; // TODO: Add support.\n\n\nconst createAnimatorManagerSequence = () => {\n  const transitionChildren = () => {};\n\n  return Object.freeze({\n    name: SEQUENCE,\n    transitionChildren\n  });\n};\n\nconst createAnimatorManager = (parent, manager) => {\n  switch (manager) {\n    case STAGGER:\n      return createAnimatorManagerStagger(parent);\n\n    case SEQUENCE:\n      return createAnimatorManagerSequence(parent);\n\n    default:\n      return createAnimatorManagerParallel(parent);\n  }\n};\n\nconst ANIMATOR_DEFAULT_MACHINE = Object.freeze({\n  initialState: EXITED,\n  states: {\n    [EXITED]: {\n      onActions: {\n        [ENTER_START]: ENTERING\n      }\n    },\n    [ENTERING]: {\n      onEntry: {\n        schedule: node => {\n          const {\n            duration: {\n              delay = 0,\n              enter = 0\n            } = {}\n          } = node.control.getSettings();\n          return {\n            duration: delay + enter,\n            action: ENTER_END\n          };\n        }\n      },\n      onActions: {\n        [ENTER_END]: ENTERED,\n        [EXIT_START]: EXITING\n      }\n    },\n    [ENTERED]: {\n      onActions: {\n        [EXIT_START]: EXITING\n      }\n    },\n    [EXITING]: {\n      onEntry: {\n        schedule: node => {\n          var _a;\n\n          return {\n            duration: ((_a = node.control.getSettings().duration) === null || _a === void 0 ? void 0 : _a.exit) || 0,\n            action: EXIT_END\n          };\n        }\n      },\n      onActions: {\n        [EXIT_END]: EXITED,\n        [ENTER_START]: ENTERING\n      }\n    }\n  },\n  onCreate: node => {\n    const settings = node.control.getSettings();\n    node.context.manager = createAnimatorManager(node, settings.manager);\n  },\n  onTransition: node => {\n    const state = node.getState();\n    const {\n      combine\n    } = node.control.getSettings();\n    const manager = node.context.manager;\n\n    switch (state) {\n      case ENTERING:\n        {\n          const children = combine ? Array.from(node.children) : Array.from(node.children).filter(child => child.control.getSettings().merge);\n          manager.transitionChildren(children);\n          break;\n        }\n\n      case ENTERED:\n        {\n          if (combine) {\n            break;\n          }\n\n          const children = Array.from(node.children).filter(child => !child.control.getSettings().merge);\n          manager.transitionChildren(children);\n          break;\n        }\n\n      case EXITING:\n        {\n          Array.from(node.children).forEach(child => {\n            const childState = child.getState();\n\n            if (childState === ENTERING || childState === ENTERED) {\n              child.send(EXIT_START);\n            } else if (childState === EXITED) {\n              child.scheduler.stop();\n            } // If the child is EXITING, it will go to EXITED soon.\n\n          });\n          break;\n        }\n    }\n  },\n  onInitialTransition: node => {\n    if (node.parent) {\n      const settings = node.control.getSettings();\n      const parentState = node.parent.getState();\n      const parentSettings = node.parent.control.getSettings();\n      const parentManager = node.parent.context.manager;\n\n      switch (parentState) {\n        case ENTERING:\n          {\n            if (parentSettings.combine || settings.merge) {\n              parentManager.transitionChildren([node]);\n            }\n\n            break;\n          }\n\n        case ENTERED:\n          {\n            // If the parent has already ENTERED, enter the incoming children whether\n            // they have \"merge\" setting or the parent is in \"combine\" setting.\n            parentManager.transitionChildren([node]);\n            break;\n          }\n      }\n    }\n  },\n  onSettingsChange: node => {\n    const state = node.getState();\n    const settings = node.control.getSettings();\n    const manager = node.context.manager;\n\n    if (!node.parent) {\n      const isActive = settings.active === true || settings.active === undefined;\n\n      if ((state === EXITED || state === EXITING) && isActive) {\n        node.send(ENTER_START);\n      } else if ((state === ENTERED || state === ENTERING) && !isActive) {\n        node.send(EXIT_START);\n      }\n    }\n\n    if (!manager || manager.name !== settings.manager) {\n      node.context.manager = createAnimatorManager(node, settings.manager);\n    }\n  }\n});\nconst ANIMATOR_DEFAULT_DURATION = Object.freeze({\n  enter: 0.4,\n  exit: 0.4,\n  delay: 0,\n  offset: 0,\n  stagger: 0.04,\n  interval: 4\n});\nconst ANIMATOR_DEFAULT_MANAGER = PARALLEL;\nconst ANIMATOR_DEFAULT_PROPS = {\n  machine: ANIMATOR_DEFAULT_MACHINE,\n  duration: ANIMATOR_DEFAULT_DURATION,\n  manager: ANIMATOR_DEFAULT_MANAGER\n};\nexport { ANIMATOR_DEFAULT_KEYS, ANIMATOR_DEFAULT_MACHINE, ANIMATOR_DEFAULT_DURATION, ANIMATOR_DEFAULT_MANAGER, ANIMATOR_DEFAULT_PROPS };","map":{"version":3,"sources":["/Users/shyanw/Documents/Nasa-Project/client/node_modules/@arwes/animator/build/esm/constants.js"],"names":["ENTERED","ENTERING","EXITING","EXITED","ENTER_START","ENTER_END","EXIT_START","EXIT_END","PARALLEL","SEQUENCE","STAGGER","ANIMATOR_DEFAULT_KEYS","createAnimatorManagerParallel","transitionChildren","children","forEach","child","send","Object","freeze","name","createAnimatorManagerStagger","parent","reservedUntilTime","_a","parentSettings","control","getSettings","stagger","duration","now","Date","undefined","Math","max","childSettings","offset","delay","scheduler","start","createAnimatorManagerSequence","createAnimatorManager","manager","ANIMATOR_DEFAULT_MACHINE","initialState","states","onActions","onEntry","schedule","node","enter","action","exit","onCreate","settings","context","onTransition","state","getState","combine","Array","from","filter","merge","childState","stop","onInitialTransition","parentState","parentManager","onSettingsChange","isActive","active","ANIMATOR_DEFAULT_DURATION","interval","ANIMATOR_DEFAULT_MANAGER","ANIMATOR_DEFAULT_PROPS","machine"],"mappings":"AAAA;AACA,MAAMA,OAAO,GAAG,SAAhB;AACA,MAAMC,QAAQ,GAAG,UAAjB;AACA,MAAMC,OAAO,GAAG,SAAhB;AACA,MAAMC,MAAM,GAAG,QAAf,C,CACA;;AACA,MAAMC,WAAW,GAAG,YAApB;AACA,MAAMC,SAAS,GAAG,UAAlB;AACA,MAAMC,UAAU,GAAG,WAAnB;AACA,MAAMC,QAAQ,GAAG,SAAjB,C,CACA;;AACA,MAAMC,QAAQ,GAAG,UAAjB;AACA,MAAMC,QAAQ,GAAG,UAAjB;AACA,MAAMC,OAAO,GAAG,SAAhB;AACA,MAAMC,qBAAqB,GAAG;AAC1BX,EAAAA,OAD0B;AAE1BC,EAAAA,QAF0B;AAG1BC,EAAAA,OAH0B;AAI1BC,EAAAA,MAJ0B;AAK1BC,EAAAA,WAL0B;AAM1BC,EAAAA,SAN0B;AAO1BC,EAAAA,UAP0B;AAQ1BC,EAAAA,QAR0B;AAS1BC,EAAAA,QAT0B;AAU1BC,EAAAA,QAV0B;AAW1BC,EAAAA;AAX0B,CAA9B;;AAaA,MAAME,6BAA6B,GAAG,MAAM;AACxC,QAAMC,kBAAkB,GAAIC,QAAD,IAAc;AACrCA,IAAAA,QAAQ,CAACC,OAAT,CAAiBC,KAAK,IAAIA,KAAK,CAACC,IAAN,CAAWb,WAAX,CAA1B;AACH,GAFD;;AAGA,SAAOc,MAAM,CAACC,MAAP,CAAc;AAAEC,IAAAA,IAAI,EAAEZ,QAAR;AAAkBK,IAAAA;AAAlB,GAAd,CAAP;AACH,CALD;;AAMA,MAAMQ,4BAA4B,GAAGC,MAAM,IAAI;AAC3C,MAAIC,iBAAJ;;AACA,QAAMV,kBAAkB,GAAIC,QAAD,IAAc;AACrC,QAAIU,EAAJ;;AACA,UAAMC,cAAc,GAAGH,MAAM,CAACI,OAAP,CAAeC,WAAf,EAAvB;AACA,UAAMC,OAAO,GAAG,CAAC,CAAC,CAACJ,EAAE,GAAGC,cAAc,CAACI,QAArB,MAAmC,IAAnC,IAA2CL,EAAE,KAAK,KAAK,CAAvD,GAA2D,KAAK,CAAhE,GAAoEA,EAAE,CAACI,OAAxE,KAAoF,CAArF,IAA0F,IAA1G,CAHqC,CAG2E;;AAChH,UAAME,GAAG,GAAGC,IAAI,CAACD,GAAL,EAAZ;AACAP,IAAAA,iBAAiB,GAAGA,iBAAiB,KAAKS,SAAtB,GACdC,IAAI,CAACC,GAAL,CAASX,iBAAT,EAA4BO,GAA5B,CADc,GAEdA,GAFN;AAGAhB,IAAAA,QAAQ,CAACC,OAAT,CAAiBC,KAAK,IAAI;AACtB,UAAIQ,EAAJ;;AACA,YAAMW,aAAa,GAAGnB,KAAK,CAACU,OAAN,CAAcC,WAAd,EAAtB;AACA,YAAMS,MAAM,GAAG,CAAC,CAAC,CAACZ,EAAE,GAAGW,aAAa,CAACN,QAApB,MAAkC,IAAlC,IAA0CL,EAAE,KAAK,KAAK,CAAtD,GAA0D,KAAK,CAA/D,GAAmEA,EAAE,CAACY,MAAvE,KAAkF,CAAnF,IAAwF,IAAvG,CAHsB,CAGuF;;AAC7Gb,MAAAA,iBAAiB,GAAGA,iBAAiB,GAAGa,MAAxC;AACA,YAAMC,KAAK,GAAG,CAACd,iBAAiB,GAAGO,GAArB,IAA4B,IAA1C,CALsB,CAK0B;;AAChDP,MAAAA,iBAAiB,GAAGA,iBAAiB,GAAGK,OAAxC;AACAZ,MAAAA,KAAK,CAACsB,SAAN,CAAgBC,KAAhB,CAAsBF,KAAtB,EAA6B,MAAMrB,KAAK,CAACC,IAAN,CAAWb,WAAX,CAAnC;AACH,KARD;AASH,GAjBD;;AAkBA,SAAOc,MAAM,CAACC,MAAP,CAAc;AAAEC,IAAAA,IAAI,EAAEV,OAAR;AAAiBG,IAAAA;AAAjB,GAAd,CAAP;AACH,CArBD,C,CAsBA;;;AACA,MAAM2B,6BAA6B,GAAG,MAAM;AACxC,QAAM3B,kBAAkB,GAAG,MAAM,CAAG,CAApC;;AACA,SAAOK,MAAM,CAACC,MAAP,CAAc;AAAEC,IAAAA,IAAI,EAAEX,QAAR;AAAkBI,IAAAA;AAAlB,GAAd,CAAP;AACH,CAHD;;AAIA,MAAM4B,qBAAqB,GAAG,CAACnB,MAAD,EAASoB,OAAT,KAAqB;AAC/C,UAAQA,OAAR;AACI,SAAKhC,OAAL;AAAc,aAAOW,4BAA4B,CAACC,MAAD,CAAnC;;AACd,SAAKb,QAAL;AAAe,aAAO+B,6BAA6B,CAAClB,MAAD,CAApC;;AACf;AAAS,aAAOV,6BAA6B,CAACU,MAAD,CAApC;AAHb;AAKH,CAND;;AAOA,MAAMqB,wBAAwB,GAAGzB,MAAM,CAACC,MAAP,CAAc;AAC3CyB,EAAAA,YAAY,EAAEzC,MAD6B;AAE3C0C,EAAAA,MAAM,EAAE;AACJ,KAAC1C,MAAD,GAAU;AACN2C,MAAAA,SAAS,EAAE;AACP,SAAC1C,WAAD,GAAeH;AADR;AADL,KADN;AAMJ,KAACA,QAAD,GAAY;AACR8C,MAAAA,OAAO,EAAE;AACLC,QAAAA,QAAQ,EAAGC,IAAD,IAAU;AAChB,gBAAM;AAAEpB,YAAAA,QAAQ,EAAE;AAAEQ,cAAAA,KAAK,GAAG,CAAV;AAAaa,cAAAA,KAAK,GAAG;AAArB,gBAA2B;AAAvC,cAA8CD,IAAI,CAACvB,OAAL,CAAaC,WAAb,EAApD;AACA,iBAAO;AACHE,YAAAA,QAAQ,EAAEQ,KAAK,GAAGa,KADf;AAEHC,YAAAA,MAAM,EAAE9C;AAFL,WAAP;AAIH;AAPI,OADD;AAURyC,MAAAA,SAAS,EAAE;AACP,SAACzC,SAAD,GAAaL,OADN;AAEP,SAACM,UAAD,GAAcJ;AAFP;AAVH,KANR;AAqBJ,KAACF,OAAD,GAAW;AACP8C,MAAAA,SAAS,EAAE;AACP,SAACxC,UAAD,GAAcJ;AADP;AADJ,KArBP;AA0BJ,KAACA,OAAD,GAAW;AACP6C,MAAAA,OAAO,EAAE;AACLC,QAAAA,QAAQ,EAAGC,IAAD,IAAU;AAChB,cAAIzB,EAAJ;;AACA,iBAAQ;AACJK,YAAAA,QAAQ,EAAE,CAAC,CAACL,EAAE,GAAGyB,IAAI,CAACvB,OAAL,CAAaC,WAAb,GAA2BE,QAAjC,MAA+C,IAA/C,IAAuDL,EAAE,KAAK,KAAK,CAAnE,GAAuE,KAAK,CAA5E,GAAgFA,EAAE,CAAC4B,IAApF,KAA6F,CADnG;AAEJD,YAAAA,MAAM,EAAE5C;AAFJ,WAAR;AAIH;AAPI,OADF;AAUPuC,MAAAA,SAAS,EAAE;AACP,SAACvC,QAAD,GAAYJ,MADL;AAEP,SAACC,WAAD,GAAeH;AAFR;AAVJ;AA1BP,GAFmC;AA4C3CoD,EAAAA,QAAQ,EAAGJ,IAAD,IAAU;AAChB,UAAMK,QAAQ,GAAGL,IAAI,CAACvB,OAAL,CAAaC,WAAb,EAAjB;AACAsB,IAAAA,IAAI,CAACM,OAAL,CAAab,OAAb,GAAuBD,qBAAqB,CAACQ,IAAD,EAAOK,QAAQ,CAACZ,OAAhB,CAA5C;AACH,GA/C0C;AAgD3Cc,EAAAA,YAAY,EAAGP,IAAD,IAAU;AACpB,UAAMQ,KAAK,GAAGR,IAAI,CAACS,QAAL,EAAd;AACA,UAAM;AAAEC,MAAAA;AAAF,QAAcV,IAAI,CAACvB,OAAL,CAAaC,WAAb,EAApB;AACA,UAAMe,OAAO,GAAGO,IAAI,CAACM,OAAL,CAAab,OAA7B;;AACA,YAAQe,KAAR;AACI,WAAKxD,QAAL;AAAe;AACX,gBAAMa,QAAQ,GAAG6C,OAAO,GAClBC,KAAK,CAACC,IAAN,CAAWZ,IAAI,CAACnC,QAAhB,CADkB,GAElB8C,KAAK,CAACC,IAAN,CAAWZ,IAAI,CAACnC,QAAhB,EAA0BgD,MAA1B,CAAiC9C,KAAK,IAAIA,KAAK,CAACU,OAAN,CAAcC,WAAd,GAA4BoC,KAAtE,CAFN;AAGArB,UAAAA,OAAO,CAAC7B,kBAAR,CAA2BC,QAA3B;AACA;AACH;;AACD,WAAKd,OAAL;AAAc;AACV,cAAI2D,OAAJ,EAAa;AACT;AACH;;AACD,gBAAM7C,QAAQ,GAAG8C,KAAK,CAACC,IAAN,CAAWZ,IAAI,CAACnC,QAAhB,EAA0BgD,MAA1B,CAAiC9C,KAAK,IAAI,CAACA,KAAK,CAACU,OAAN,CAAcC,WAAd,GAA4BoC,KAAvE,CAAjB;AACArB,UAAAA,OAAO,CAAC7B,kBAAR,CAA2BC,QAA3B;AACA;AACH;;AACD,WAAKZ,OAAL;AAAc;AACV0D,UAAAA,KAAK,CAACC,IAAN,CAAWZ,IAAI,CAACnC,QAAhB,EAA0BC,OAA1B,CAAkCC,KAAK,IAAI;AACvC,kBAAMgD,UAAU,GAAGhD,KAAK,CAAC0C,QAAN,EAAnB;;AACA,gBAAIM,UAAU,KAAK/D,QAAf,IAA2B+D,UAAU,KAAKhE,OAA9C,EAAuD;AACnDgB,cAAAA,KAAK,CAACC,IAAN,CAAWX,UAAX;AACH,aAFD,MAGK,IAAI0D,UAAU,KAAK7D,MAAnB,EAA2B;AAC5Ba,cAAAA,KAAK,CAACsB,SAAN,CAAgB2B,IAAhB;AACH,aAPsC,CAQvC;;AACH,WATD;AAUA;AACH;AA5BL;AA8BH,GAlF0C;AAmF3CC,EAAAA,mBAAmB,EAAGjB,IAAD,IAAU;AAC3B,QAAIA,IAAI,CAAC3B,MAAT,EAAiB;AACb,YAAMgC,QAAQ,GAAGL,IAAI,CAACvB,OAAL,CAAaC,WAAb,EAAjB;AACA,YAAMwC,WAAW,GAAGlB,IAAI,CAAC3B,MAAL,CAAYoC,QAAZ,EAApB;AACA,YAAMjC,cAAc,GAAGwB,IAAI,CAAC3B,MAAL,CAAYI,OAAZ,CAAoBC,WAApB,EAAvB;AACA,YAAMyC,aAAa,GAAGnB,IAAI,CAAC3B,MAAL,CAAYiC,OAAZ,CAAoBb,OAA1C;;AACA,cAAQyB,WAAR;AACI,aAAKlE,QAAL;AAAe;AACX,gBAAIwB,cAAc,CAACkC,OAAf,IAA0BL,QAAQ,CAACS,KAAvC,EAA8C;AAC1CK,cAAAA,aAAa,CAACvD,kBAAd,CAAiC,CAACoC,IAAD,CAAjC;AACH;;AACD;AACH;;AACD,aAAKjD,OAAL;AAAc;AACV;AACA;AACAoE,YAAAA,aAAa,CAACvD,kBAAd,CAAiC,CAACoC,IAAD,CAAjC;AACA;AACH;AAZL;AAcH;AACJ,GAxG0C;AAyG3CoB,EAAAA,gBAAgB,EAAGpB,IAAD,IAAU;AACxB,UAAMQ,KAAK,GAAGR,IAAI,CAACS,QAAL,EAAd;AACA,UAAMJ,QAAQ,GAAGL,IAAI,CAACvB,OAAL,CAAaC,WAAb,EAAjB;AACA,UAAMe,OAAO,GAAGO,IAAI,CAACM,OAAL,CAAab,OAA7B;;AACA,QAAI,CAACO,IAAI,CAAC3B,MAAV,EAAkB;AACd,YAAMgD,QAAQ,GAAGhB,QAAQ,CAACiB,MAAT,KAAoB,IAApB,IAA4BjB,QAAQ,CAACiB,MAAT,KAAoBvC,SAAjE;;AACA,UAAI,CAACyB,KAAK,KAAKtD,MAAV,IAAoBsD,KAAK,KAAKvD,OAA/B,KAA2CoE,QAA/C,EAAyD;AACrDrB,QAAAA,IAAI,CAAChC,IAAL,CAAUb,WAAV;AACH,OAFD,MAGK,IAAI,CAACqD,KAAK,KAAKzD,OAAV,IAAqByD,KAAK,KAAKxD,QAAhC,KAA6C,CAACqE,QAAlD,EAA4D;AAC7DrB,QAAAA,IAAI,CAAChC,IAAL,CAAUX,UAAV;AACH;AACJ;;AACD,QAAI,CAACoC,OAAD,IAAYA,OAAO,CAACtB,IAAR,KAAiBkC,QAAQ,CAACZ,OAA1C,EAAmD;AAC/CO,MAAAA,IAAI,CAACM,OAAL,CAAab,OAAb,GAAuBD,qBAAqB,CAACQ,IAAD,EAAOK,QAAQ,CAACZ,OAAhB,CAA5C;AACH;AACJ;AAzH0C,CAAd,CAAjC;AA2HA,MAAM8B,yBAAyB,GAAGtD,MAAM,CAACC,MAAP,CAAc;AAC5C+B,EAAAA,KAAK,EAAE,GADqC;AAE5CE,EAAAA,IAAI,EAAE,GAFsC;AAG5Cf,EAAAA,KAAK,EAAE,CAHqC;AAI5CD,EAAAA,MAAM,EAAE,CAJoC;AAK5CR,EAAAA,OAAO,EAAE,IALmC;AAM5C6C,EAAAA,QAAQ,EAAE;AANkC,CAAd,CAAlC;AAQA,MAAMC,wBAAwB,GAAGlE,QAAjC;AACA,MAAMmE,sBAAsB,GAAG;AAC3BC,EAAAA,OAAO,EAAEjC,wBADkB;AAE3Bd,EAAAA,QAAQ,EAAE2C,yBAFiB;AAG3B9B,EAAAA,OAAO,EAAEgC;AAHkB,CAA/B;AAKA,SAAS/D,qBAAT,EAAgCgC,wBAAhC,EAA0D6B,yBAA1D,EAAqFE,wBAArF,EAA+GC,sBAA/G","sourcesContent":["// States\nconst ENTERED = 'entered';\nconst ENTERING = 'entering';\nconst EXITING = 'exiting';\nconst EXITED = 'exited';\n// Actions\nconst ENTER_START = 'enterStart';\nconst ENTER_END = 'enterEnd';\nconst EXIT_START = 'exitStart';\nconst EXIT_END = 'exitEnd';\n// Managers\nconst PARALLEL = 'parallel';\nconst SEQUENCE = 'sequence';\nconst STAGGER = 'stagger';\nconst ANIMATOR_DEFAULT_KEYS = {\n    ENTERED,\n    ENTERING,\n    EXITING,\n    EXITED,\n    ENTER_START,\n    ENTER_END,\n    EXIT_START,\n    EXIT_END,\n    PARALLEL,\n    SEQUENCE,\n    STAGGER\n};\nconst createAnimatorManagerParallel = () => {\n    const transitionChildren = (children) => {\n        children.forEach(child => child.send(ENTER_START));\n    };\n    return Object.freeze({ name: PARALLEL, transitionChildren });\n};\nconst createAnimatorManagerStagger = parent => {\n    let reservedUntilTime;\n    const transitionChildren = (children) => {\n        var _a;\n        const parentSettings = parent.control.getSettings();\n        const stagger = (((_a = parentSettings.duration) === null || _a === void 0 ? void 0 : _a.stagger) || 0) * 1000; // seconds to ms\n        const now = Date.now();\n        reservedUntilTime = reservedUntilTime !== undefined\n            ? Math.max(reservedUntilTime, now)\n            : now;\n        children.forEach(child => {\n            var _a;\n            const childSettings = child.control.getSettings();\n            const offset = (((_a = childSettings.duration) === null || _a === void 0 ? void 0 : _a.offset) || 0) * 1000; // seconds to ms\n            reservedUntilTime = reservedUntilTime + offset;\n            const delay = (reservedUntilTime - now) / 1000; // ms to seconds\n            reservedUntilTime = reservedUntilTime + stagger;\n            child.scheduler.start(delay, () => child.send(ENTER_START));\n        });\n    };\n    return Object.freeze({ name: STAGGER, transitionChildren });\n};\n// TODO: Add support.\nconst createAnimatorManagerSequence = () => {\n    const transitionChildren = () => { };\n    return Object.freeze({ name: SEQUENCE, transitionChildren });\n};\nconst createAnimatorManager = (parent, manager) => {\n    switch (manager) {\n        case STAGGER: return createAnimatorManagerStagger(parent);\n        case SEQUENCE: return createAnimatorManagerSequence(parent);\n        default: return createAnimatorManagerParallel(parent);\n    }\n};\nconst ANIMATOR_DEFAULT_MACHINE = Object.freeze({\n    initialState: EXITED,\n    states: {\n        [EXITED]: {\n            onActions: {\n                [ENTER_START]: ENTERING\n            }\n        },\n        [ENTERING]: {\n            onEntry: {\n                schedule: (node) => {\n                    const { duration: { delay = 0, enter = 0 } = {} } = node.control.getSettings();\n                    return {\n                        duration: delay + enter,\n                        action: ENTER_END\n                    };\n                }\n            },\n            onActions: {\n                [ENTER_END]: ENTERED,\n                [EXIT_START]: EXITING\n            }\n        },\n        [ENTERED]: {\n            onActions: {\n                [EXIT_START]: EXITING\n            }\n        },\n        [EXITING]: {\n            onEntry: {\n                schedule: (node) => {\n                    var _a;\n                    return ({\n                        duration: ((_a = node.control.getSettings().duration) === null || _a === void 0 ? void 0 : _a.exit) || 0,\n                        action: EXIT_END\n                    });\n                }\n            },\n            onActions: {\n                [EXIT_END]: EXITED,\n                [ENTER_START]: ENTERING\n            }\n        }\n    },\n    onCreate: (node) => {\n        const settings = node.control.getSettings();\n        node.context.manager = createAnimatorManager(node, settings.manager);\n    },\n    onTransition: (node) => {\n        const state = node.getState();\n        const { combine } = node.control.getSettings();\n        const manager = node.context.manager;\n        switch (state) {\n            case ENTERING: {\n                const children = combine\n                    ? Array.from(node.children)\n                    : Array.from(node.children).filter(child => child.control.getSettings().merge);\n                manager.transitionChildren(children);\n                break;\n            }\n            case ENTERED: {\n                if (combine) {\n                    break;\n                }\n                const children = Array.from(node.children).filter(child => !child.control.getSettings().merge);\n                manager.transitionChildren(children);\n                break;\n            }\n            case EXITING: {\n                Array.from(node.children).forEach(child => {\n                    const childState = child.getState();\n                    if (childState === ENTERING || childState === ENTERED) {\n                        child.send(EXIT_START);\n                    }\n                    else if (childState === EXITED) {\n                        child.scheduler.stop();\n                    }\n                    // If the child is EXITING, it will go to EXITED soon.\n                });\n                break;\n            }\n        }\n    },\n    onInitialTransition: (node) => {\n        if (node.parent) {\n            const settings = node.control.getSettings();\n            const parentState = node.parent.getState();\n            const parentSettings = node.parent.control.getSettings();\n            const parentManager = node.parent.context.manager;\n            switch (parentState) {\n                case ENTERING: {\n                    if (parentSettings.combine || settings.merge) {\n                        parentManager.transitionChildren([node]);\n                    }\n                    break;\n                }\n                case ENTERED: {\n                    // If the parent has already ENTERED, enter the incoming children whether\n                    // they have \"merge\" setting or the parent is in \"combine\" setting.\n                    parentManager.transitionChildren([node]);\n                    break;\n                }\n            }\n        }\n    },\n    onSettingsChange: (node) => {\n        const state = node.getState();\n        const settings = node.control.getSettings();\n        const manager = node.context.manager;\n        if (!node.parent) {\n            const isActive = settings.active === true || settings.active === undefined;\n            if ((state === EXITED || state === EXITING) && isActive) {\n                node.send(ENTER_START);\n            }\n            else if ((state === ENTERED || state === ENTERING) && !isActive) {\n                node.send(EXIT_START);\n            }\n        }\n        if (!manager || manager.name !== settings.manager) {\n            node.context.manager = createAnimatorManager(node, settings.manager);\n        }\n    }\n});\nconst ANIMATOR_DEFAULT_DURATION = Object.freeze({\n    enter: 0.4,\n    exit: 0.4,\n    delay: 0,\n    offset: 0,\n    stagger: 0.04,\n    interval: 4\n});\nconst ANIMATOR_DEFAULT_MANAGER = PARALLEL;\nconst ANIMATOR_DEFAULT_PROPS = {\n    machine: ANIMATOR_DEFAULT_MACHINE,\n    duration: ANIMATOR_DEFAULT_DURATION,\n    manager: ANIMATOR_DEFAULT_MANAGER\n};\nexport { ANIMATOR_DEFAULT_KEYS, ANIMATOR_DEFAULT_MACHINE, ANIMATOR_DEFAULT_DURATION, ANIMATOR_DEFAULT_MANAGER, ANIMATOR_DEFAULT_PROPS };\n"]},"metadata":{},"sourceType":"module"}