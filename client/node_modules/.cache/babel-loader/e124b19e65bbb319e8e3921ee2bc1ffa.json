{"ast":null,"code":"import { Howler, Howl } from 'howler';\n\nconst createBleep = (audioSettings, playerSettings) => {\n  const {\n    disabled,\n    ...settings\n  } = { ...audioSettings,\n    ...playerSettings\n  }; // TODO: The Howler API does not provide a public interface to know if\n  // the browser audio is locked or not. But it has a private flag.\n  // This could potentially break this library if it changes unexpectedly,\n  // but there is no proper way to know.\n\n  const isGlobalAudioLocked = !Howler._audioUnlocked;\n  let isLocked = isGlobalAudioLocked;\n  let lastId;\n  const howl = new Howl({ ...settings,\n    onunlock: () => {\n      isLocked = false;\n    }\n  }); // In a loop sound, if the sound is played by multiple sources\n  // (e.g. multiple components multiple times), to stop the sound,\n  // all of the play() calls must also call stop().\n  // Otherwise, a race-condition issue can happen.\n\n  const sourcesAccount = {};\n\n  const play = instanceId => {\n    // Even if the audio is set up to be preloaded, sometimes the file\n    // is not loaded, probably because the browser has locked the playback.\n    if (howl.state() === 'unloaded') {\n      howl.load();\n    } // If the browser audio is locked, if the audio is played, it will be queued\n    // until the browser audio is unlocked. But if in-between the audio is stopped,\n    // the play is still queued. It is also accumulated, regardless of passing down\n    // the same playback id.\n\n\n    if (isLocked) {\n      return;\n    }\n\n    sourcesAccount[instanceId] = true; // If the sound is being loaded, the play action will be\n    // queued until it is loaded.\n\n    const newId = howl.play(lastId); // If the sound is being loaded, it returns null.\n    // To prevent errors, the id to pass to play must be a number or undefined.\n\n    lastId = newId || undefined;\n  };\n\n  const stop = instanceId => {\n    delete sourcesAccount[instanceId]; // eslint-disable-line @typescript-eslint/no-dynamic-delete\n\n    const noActiveSources = !Object.keys(sourcesAccount).length;\n    const canStop = settings.loop ? noActiveSources : true;\n\n    if (canStop && howl.playing()) {\n      howl.stop();\n    }\n  };\n\n  const getIsPlaying = () => {\n    return howl.playing();\n  };\n\n  const getDuration = () => {\n    return howl.duration();\n  };\n\n  const unload = () => {\n    howl.unload();\n  };\n\n  return {\n    _settings: settings,\n    _howl: howl,\n    play,\n    stop,\n    getIsPlaying,\n    getDuration,\n    unload\n  };\n};\n\nexport { createBleep };","map":{"version":3,"sources":["/Users/shyanw/Documents/Nasa-Project/client/node_modules/@arwes/bleeps/build/esm/createBleep/createBleep.js"],"names":["Howler","Howl","createBleep","audioSettings","playerSettings","disabled","settings","isGlobalAudioLocked","_audioUnlocked","isLocked","lastId","howl","onunlock","sourcesAccount","play","instanceId","state","load","newId","undefined","stop","noActiveSources","Object","keys","length","canStop","loop","playing","getIsPlaying","getDuration","duration","unload","_settings","_howl"],"mappings":"AAAA,SAASA,MAAT,EAAiBC,IAAjB,QAA6B,QAA7B;;AACA,MAAMC,WAAW,GAAG,CAACC,aAAD,EAAgBC,cAAhB,KAAmC;AACnD,QAAM;AAAEC,IAAAA,QAAF;AAAY,OAAGC;AAAf,MAA4B,EAC9B,GAAGH,aAD2B;AAE9B,OAAGC;AAF2B,GAAlC,CADmD,CAKnD;AACA;AACA;AACA;;AACA,QAAMG,mBAAmB,GAAG,CAACP,MAAM,CAACQ,cAApC;AACA,MAAIC,QAAQ,GAAGF,mBAAf;AACA,MAAIG,MAAJ;AACA,QAAMC,IAAI,GAAG,IAAIV,IAAJ,CAAS,EAClB,GAAGK,QADe;AAElBM,IAAAA,QAAQ,EAAE,MAAM;AACZH,MAAAA,QAAQ,GAAG,KAAX;AACH;AAJiB,GAAT,CAAb,CAZmD,CAkBnD;AACA;AACA;AACA;;AACA,QAAMI,cAAc,GAAG,EAAvB;;AACA,QAAMC,IAAI,GAAIC,UAAD,IAAgB;AACzB;AACA;AACA,QAAIJ,IAAI,CAACK,KAAL,OAAiB,UAArB,EAAiC;AAC7BL,MAAAA,IAAI,CAACM,IAAL;AACH,KALwB,CAMzB;AACA;AACA;AACA;;;AACA,QAAIR,QAAJ,EAAc;AACV;AACH;;AACDI,IAAAA,cAAc,CAACE,UAAD,CAAd,GAA6B,IAA7B,CAbyB,CAczB;AACA;;AACA,UAAMG,KAAK,GAAGP,IAAI,CAACG,IAAL,CAAUJ,MAAV,CAAd,CAhByB,CAiBzB;AACA;;AACAA,IAAAA,MAAM,GAAGQ,KAAK,IAAIC,SAAlB;AACH,GApBD;;AAqBA,QAAMC,IAAI,GAAIL,UAAD,IAAgB;AACzB,WAAOF,cAAc,CAACE,UAAD,CAArB,CADyB,CACU;;AACnC,UAAMM,eAAe,GAAG,CAACC,MAAM,CAACC,IAAP,CAAYV,cAAZ,EAA4BW,MAArD;AACA,UAAMC,OAAO,GAAGnB,QAAQ,CAACoB,IAAT,GAAgBL,eAAhB,GAAkC,IAAlD;;AACA,QAAII,OAAO,IAAId,IAAI,CAACgB,OAAL,EAAf,EAA+B;AAC3BhB,MAAAA,IAAI,CAACS,IAAL;AACH;AACJ,GAPD;;AAQA,QAAMQ,YAAY,GAAG,MAAM;AACvB,WAAOjB,IAAI,CAACgB,OAAL,EAAP;AACH,GAFD;;AAGA,QAAME,WAAW,GAAG,MAAM;AACtB,WAAOlB,IAAI,CAACmB,QAAL,EAAP;AACH,GAFD;;AAGA,QAAMC,MAAM,GAAG,MAAM;AACjBpB,IAAAA,IAAI,CAACoB,MAAL;AACH,GAFD;;AAGA,SAAO;AACHC,IAAAA,SAAS,EAAE1B,QADR;AAEH2B,IAAAA,KAAK,EAAEtB,IAFJ;AAGHG,IAAAA,IAHG;AAIHM,IAAAA,IAJG;AAKHQ,IAAAA,YALG;AAMHC,IAAAA,WANG;AAOHE,IAAAA;AAPG,GAAP;AASH,CAtED;;AAuEA,SAAS7B,WAAT","sourcesContent":["import { Howler, Howl } from 'howler';\nconst createBleep = (audioSettings, playerSettings) => {\n    const { disabled, ...settings } = {\n        ...audioSettings,\n        ...playerSettings\n    };\n    // TODO: The Howler API does not provide a public interface to know if\n    // the browser audio is locked or not. But it has a private flag.\n    // This could potentially break this library if it changes unexpectedly,\n    // but there is no proper way to know.\n    const isGlobalAudioLocked = !Howler._audioUnlocked;\n    let isLocked = isGlobalAudioLocked;\n    let lastId;\n    const howl = new Howl({\n        ...settings,\n        onunlock: () => {\n            isLocked = false;\n        }\n    });\n    // In a loop sound, if the sound is played by multiple sources\n    // (e.g. multiple components multiple times), to stop the sound,\n    // all of the play() calls must also call stop().\n    // Otherwise, a race-condition issue can happen.\n    const sourcesAccount = {};\n    const play = (instanceId) => {\n        // Even if the audio is set up to be preloaded, sometimes the file\n        // is not loaded, probably because the browser has locked the playback.\n        if (howl.state() === 'unloaded') {\n            howl.load();\n        }\n        // If the browser audio is locked, if the audio is played, it will be queued\n        // until the browser audio is unlocked. But if in-between the audio is stopped,\n        // the play is still queued. It is also accumulated, regardless of passing down\n        // the same playback id.\n        if (isLocked) {\n            return;\n        }\n        sourcesAccount[instanceId] = true;\n        // If the sound is being loaded, the play action will be\n        // queued until it is loaded.\n        const newId = howl.play(lastId);\n        // If the sound is being loaded, it returns null.\n        // To prevent errors, the id to pass to play must be a number or undefined.\n        lastId = newId || undefined;\n    };\n    const stop = (instanceId) => {\n        delete sourcesAccount[instanceId]; // eslint-disable-line @typescript-eslint/no-dynamic-delete\n        const noActiveSources = !Object.keys(sourcesAccount).length;\n        const canStop = settings.loop ? noActiveSources : true;\n        if (canStop && howl.playing()) {\n            howl.stop();\n        }\n    };\n    const getIsPlaying = () => {\n        return howl.playing();\n    };\n    const getDuration = () => {\n        return howl.duration();\n    };\n    const unload = () => {\n        howl.unload();\n    };\n    return {\n        _settings: settings,\n        _howl: howl,\n        play,\n        stop,\n        getIsPlaying,\n        getDuration,\n        unload\n    };\n};\nexport { createBleep };\n"]},"metadata":{},"sourceType":"module"}