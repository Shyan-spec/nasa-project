{"ast":null,"code":"import { TOOLS_IS_BROWSER, createTOScheduler } from '@arwes/tools'; // TODO: Animator with \"combine\" should have its duration as the total duration\n// of its children's durations.\n// TODO: The scheduling right now is as follows:\n// 1. Animator setup node\n// 2. System create node\n// 3. System schedules node setup\n// 3. Animator schedules control change\n// 3. Component subscribes to node\n// 4. System node setup\n// 5. System node transition\n// 6. Machine run control change\n// 6. System node transitions if applicable\n// The sequence of events is not playing with the React scheduling system.\n// And the initial schedules (setup and change) complicates the system.\n// There should be a simpler way to sync with the React system to setup and\n// properly detect for control changes for transitions.\n\nconst createAnimatorSystem = () => {\n  let idCounter = 0;\n  let root;\n\n  const createNode = (parent, control) => {\n    const {\n      machine\n    } = control.getSettings();\n\n    if (!machine) {\n      throw new Error('A machine is required to create an animator node.');\n    }\n\n    const id = idCounter++;\n    let node; // eslint-disable-line prefer-const\n\n    let state = '';\n\n    const transition = newState => {\n      var _a;\n\n      if (state === newState) {\n        return;\n      }\n\n      state = newState;\n      const nodeScoped = node;\n      const {\n        onEntry\n      } = machine.states[state] || {};\n      const {\n        onTransition\n      } = control.getSettings();\n\n      if (onEntry === null || onEntry === void 0 ? void 0 : onEntry.execute) {\n        onEntry.execute(nodeScoped);\n      }\n\n      if (onEntry === null || onEntry === void 0 ? void 0 : onEntry.schedule) {\n        const task = onEntry.schedule(nodeScoped);\n\n        if (!Number.isFinite(task.duration) || task.duration < 0 || !task.action.length) {\n          throw new Error('Machine state schedule must return a valid duration and action name.');\n        }\n\n        nodeScoped.scheduler.start(task.duration, () => send(task.action));\n      }\n\n      (_a = machine.onTransition) === null || _a === void 0 ? void 0 : _a.call(machine, nodeScoped);\n      onTransition === null || onTransition === void 0 ? void 0 : onTransition(nodeScoped);\n\n      for (const subscriber of nodeScoped.subscribers) {\n        subscriber(nodeScoped);\n      }\n    };\n\n    const send = action => {\n      var _a, _b;\n\n      const newState = (_b = (_a = machine.states[state]) === null || _a === void 0 ? void 0 : _a.onActions) === null || _b === void 0 ? void 0 : _b[action];\n\n      if (newState) {\n        transition(newState);\n      }\n    };\n\n    const onSettingsChange = () => {\n      const nodeScoped = node; // Schedule after React useEffects have taken effect so the potential\n      // subscribers have been subscribed and the node setup has been done.\n\n      nodeScoped.scheduler.start('change', 0.001, () => {\n        var _a;\n\n        (_a = machine.onSettingsChange) === null || _a === void 0 ? void 0 : _a.call(machine, nodeScoped);\n      });\n    };\n\n    node = Object.freeze({\n      id,\n      control,\n      parent,\n      children: new Set(),\n      subscribers: new Set(),\n      scheduler: createTOScheduler(),\n      context: {},\n      getState: () => state,\n      send,\n      onSettingsChange\n    });\n\n    if (parent) {\n      parent.children.add(node);\n    }\n\n    if (TOOLS_IS_BROWSER) {\n      // Schedule after React useEffects have taken effect so the potential\n      // subscribers have been subscribed and before any node change.\n      node.scheduler.start('setup', 0.001, () => {\n        var _a, _b;\n\n        const nodeScoped = node;\n        (_a = machine.onCreate) === null || _a === void 0 ? void 0 : _a.call(machine, nodeScoped);\n        transition(machine.initialState);\n        (_b = machine.onInitialTransition) === null || _b === void 0 ? void 0 : _b.call(machine, nodeScoped);\n      });\n    }\n\n    return node;\n  };\n\n  const removeNode = node => {\n    node.scheduler.stopAll();\n\n    for (const child of node.children) {\n      removeNode(child);\n    }\n\n    if (node.parent) {\n      node.parent.children.delete(node);\n    }\n\n    node.children.clear();\n    node.subscribers.clear();\n  };\n\n  const unregister = node => {\n    if (!root) {\n      return;\n    }\n\n    removeNode(node);\n\n    if (root.id === node.id) {\n      root = undefined;\n    }\n  };\n\n  const setup = control => {\n    if (root) {\n      removeNode(root);\n    }\n\n    root = createNode(undefined, control);\n    return root;\n  };\n\n  const register = (parent, control) => {\n    if (!root) {\n      throw new Error('A root node needs to be setup before registering nodes.');\n    }\n\n    return createNode(parent, control);\n  };\n\n  return Object.freeze({\n    setup,\n    register,\n    unregister\n  });\n};\n\nexport { createAnimatorSystem };","map":{"version":3,"sources":["/Users/shyanw/Documents/Nasa-Project/client/node_modules/@arwes/animator/build/esm/createAnimatorSystem/createAnimatorSystem.js"],"names":["TOOLS_IS_BROWSER","createTOScheduler","createAnimatorSystem","idCounter","root","createNode","parent","control","machine","getSettings","Error","id","node","state","transition","newState","_a","nodeScoped","onEntry","states","onTransition","execute","schedule","task","Number","isFinite","duration","action","length","scheduler","start","send","call","subscriber","subscribers","_b","onActions","onSettingsChange","Object","freeze","children","Set","context","getState","add","onCreate","initialState","onInitialTransition","removeNode","stopAll","child","delete","clear","unregister","undefined","setup","register"],"mappings":"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","sourcesContent":["import { TOOLS_IS_BROWSER, createTOScheduler } from '@arwes/tools';\n// TODO: Animator with \"combine\" should have its duration as the total duration\n// of its children's durations.\n// TODO: The scheduling right now is as follows:\n// 1. Animator setup node\n// 2. System create node\n// 3. System schedules node setup\n// 3. Animator schedules control change\n// 3. Component subscribes to node\n// 4. System node setup\n// 5. System node transition\n// 6. Machine run control change\n// 6. System node transitions if applicable\n// The sequence of events is not playing with the React scheduling system.\n// And the initial schedules (setup and change) complicates the system.\n// There should be a simpler way to sync with the React system to setup and\n// properly detect for control changes for transitions.\nconst createAnimatorSystem = () => {\n    let idCounter = 0;\n    let root;\n    const createNode = (parent, control) => {\n        const { machine } = control.getSettings();\n        if (!machine) {\n            throw new Error('A machine is required to create an animator node.');\n        }\n        const id = idCounter++;\n        let node; // eslint-disable-line prefer-const\n        let state = '';\n        const transition = (newState) => {\n            var _a;\n            if (state === newState) {\n                return;\n            }\n            state = newState;\n            const nodeScoped = node;\n            const { onEntry } = machine.states[state] || {};\n            const { onTransition } = control.getSettings();\n            if (onEntry === null || onEntry === void 0 ? void 0 : onEntry.execute) {\n                onEntry.execute(nodeScoped);\n            }\n            if (onEntry === null || onEntry === void 0 ? void 0 : onEntry.schedule) {\n                const task = onEntry.schedule(nodeScoped);\n                if (!Number.isFinite(task.duration) || task.duration < 0 || !task.action.length) {\n                    throw new Error('Machine state schedule must return a valid duration and action name.');\n                }\n                nodeScoped.scheduler.start(task.duration, () => send(task.action));\n            }\n            (_a = machine.onTransition) === null || _a === void 0 ? void 0 : _a.call(machine, nodeScoped);\n            onTransition === null || onTransition === void 0 ? void 0 : onTransition(nodeScoped);\n            for (const subscriber of nodeScoped.subscribers) {\n                subscriber(nodeScoped);\n            }\n        };\n        const send = (action) => {\n            var _a, _b;\n            const newState = (_b = (_a = machine.states[state]) === null || _a === void 0 ? void 0 : _a.onActions) === null || _b === void 0 ? void 0 : _b[action];\n            if (newState) {\n                transition(newState);\n            }\n        };\n        const onSettingsChange = () => {\n            const nodeScoped = node;\n            // Schedule after React useEffects have taken effect so the potential\n            // subscribers have been subscribed and the node setup has been done.\n            nodeScoped.scheduler.start('change', 0.001, () => {\n                var _a;\n                (_a = machine.onSettingsChange) === null || _a === void 0 ? void 0 : _a.call(machine, nodeScoped);\n            });\n        };\n        node = Object.freeze({\n            id,\n            control,\n            parent,\n            children: new Set(),\n            subscribers: new Set(),\n            scheduler: createTOScheduler(),\n            context: {},\n            getState: () => state,\n            send,\n            onSettingsChange\n        });\n        if (parent) {\n            parent.children.add(node);\n        }\n        if (TOOLS_IS_BROWSER) {\n            // Schedule after React useEffects have taken effect so the potential\n            // subscribers have been subscribed and before any node change.\n            node.scheduler.start('setup', 0.001, () => {\n                var _a, _b;\n                const nodeScoped = node;\n                (_a = machine.onCreate) === null || _a === void 0 ? void 0 : _a.call(machine, nodeScoped);\n                transition(machine.initialState);\n                (_b = machine.onInitialTransition) === null || _b === void 0 ? void 0 : _b.call(machine, nodeScoped);\n            });\n        }\n        return node;\n    };\n    const removeNode = (node) => {\n        node.scheduler.stopAll();\n        for (const child of node.children) {\n            removeNode(child);\n        }\n        if (node.parent) {\n            node.parent.children.delete(node);\n        }\n        node.children.clear();\n        node.subscribers.clear();\n    };\n    const unregister = (node) => {\n        if (!root) {\n            return;\n        }\n        removeNode(node);\n        if (root.id === node.id) {\n            root = undefined;\n        }\n    };\n    const setup = (control) => {\n        if (root) {\n            removeNode(root);\n        }\n        root = createNode(undefined, control);\n        return root;\n    };\n    const register = (parent, control) => {\n        if (!root) {\n            throw new Error('A root node needs to be setup before registering nodes.');\n        }\n        return createNode(parent, control);\n    };\n    return Object.freeze({ setup, register, unregister });\n};\nexport { createAnimatorSystem };\n"]},"metadata":{},"sourceType":"module"}