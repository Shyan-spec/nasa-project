{"ast":null,"code":"import { Howler, Howl } from 'howler';\nconst createBleep = (audioSettings, playerSettings) => {\n  const {\n    disabled,\n    ...settings\n  } = {\n    ...audioSettings,\n    ...playerSettings\n  };\n  // TODO: The Howler API does not provide a public interface to know if\n  // the browser audio is locked or not. But it has a private flag.\n  // This could potentially break this library if it changes unexpectedly,\n  // but there is no proper way to know.\n  const isGlobalAudioLocked = !Howler._audioUnlocked;\n  let isLocked = isGlobalAudioLocked;\n  let lastId;\n  const howl = new Howl({\n    ...settings,\n    onunlock: () => {\n      isLocked = false;\n    }\n  });\n  // In a loop sound, if the sound is played by multiple sources\n  // (e.g. multiple components multiple times), to stop the sound,\n  // all of the play() calls must also call stop().\n  // Otherwise, a race-condition issue can happen.\n  const sourcesAccount = {};\n  const play = instanceId => {\n    // Even if the audio is set up to be preloaded, sometimes the file\n    // is not loaded, probably because the browser has locked the playback.\n    if (howl.state() === 'unloaded') {\n      howl.load();\n    }\n    // If the browser audio is locked, if the audio is played, it will be queued\n    // until the browser audio is unlocked. But if in-between the audio is stopped,\n    // the play is still queued. It is also accumulated, regardless of passing down\n    // the same playback id.\n    if (isLocked) {\n      return;\n    }\n    sourcesAccount[instanceId] = true;\n    // If the sound is being loaded, the play action will be\n    // queued until it is loaded.\n    const newId = howl.play(lastId);\n    // If the sound is being loaded, it returns null.\n    // To prevent errors, the id to pass to play must be a number or undefined.\n    lastId = newId || undefined;\n  };\n  const stop = instanceId => {\n    delete sourcesAccount[instanceId]; // eslint-disable-line @typescript-eslint/no-dynamic-delete\n    const noActiveSources = !Object.keys(sourcesAccount).length;\n    const canStop = settings.loop ? noActiveSources : true;\n    if (canStop && howl.playing()) {\n      howl.stop();\n    }\n  };\n  const getIsPlaying = () => {\n    return howl.playing();\n  };\n  const getDuration = () => {\n    return howl.duration();\n  };\n  const unload = () => {\n    howl.unload();\n  };\n  return {\n    _settings: settings,\n    _howl: howl,\n    play,\n    stop,\n    getIsPlaying,\n    getDuration,\n    unload\n  };\n};\nexport { createBleep };","map":{"version":3,"names":["Howler","Howl","createBleep","audioSettings","playerSettings","disabled","settings","isGlobalAudioLocked","_audioUnlocked","isLocked","lastId","howl","onunlock","sourcesAccount","play","instanceId","state","load","newId","undefined","stop","noActiveSources","Object","keys","length","canStop","loop","playing","getIsPlaying","getDuration","duration","unload","_settings","_howl"],"sources":["/Users/shyanw/Documents/Nasa-Project/client/node_modules/@arwes/bleeps/build/esm/createBleep/createBleep.js"],"sourcesContent":["import { Howler, Howl } from 'howler';\nconst createBleep = (audioSettings, playerSettings) => {\n    const { disabled, ...settings } = {\n        ...audioSettings,\n        ...playerSettings\n    };\n    // TODO: The Howler API does not provide a public interface to know if\n    // the browser audio is locked or not. But it has a private flag.\n    // This could potentially break this library if it changes unexpectedly,\n    // but there is no proper way to know.\n    const isGlobalAudioLocked = !Howler._audioUnlocked;\n    let isLocked = isGlobalAudioLocked;\n    let lastId;\n    const howl = new Howl({\n        ...settings,\n        onunlock: () => {\n            isLocked = false;\n        }\n    });\n    // In a loop sound, if the sound is played by multiple sources\n    // (e.g. multiple components multiple times), to stop the sound,\n    // all of the play() calls must also call stop().\n    // Otherwise, a race-condition issue can happen.\n    const sourcesAccount = {};\n    const play = (instanceId) => {\n        // Even if the audio is set up to be preloaded, sometimes the file\n        // is not loaded, probably because the browser has locked the playback.\n        if (howl.state() === 'unloaded') {\n            howl.load();\n        }\n        // If the browser audio is locked, if the audio is played, it will be queued\n        // until the browser audio is unlocked. But if in-between the audio is stopped,\n        // the play is still queued. It is also accumulated, regardless of passing down\n        // the same playback id.\n        if (isLocked) {\n            return;\n        }\n        sourcesAccount[instanceId] = true;\n        // If the sound is being loaded, the play action will be\n        // queued until it is loaded.\n        const newId = howl.play(lastId);\n        // If the sound is being loaded, it returns null.\n        // To prevent errors, the id to pass to play must be a number or undefined.\n        lastId = newId || undefined;\n    };\n    const stop = (instanceId) => {\n        delete sourcesAccount[instanceId]; // eslint-disable-line @typescript-eslint/no-dynamic-delete\n        const noActiveSources = !Object.keys(sourcesAccount).length;\n        const canStop = settings.loop ? noActiveSources : true;\n        if (canStop && howl.playing()) {\n            howl.stop();\n        }\n    };\n    const getIsPlaying = () => {\n        return howl.playing();\n    };\n    const getDuration = () => {\n        return howl.duration();\n    };\n    const unload = () => {\n        howl.unload();\n    };\n    return {\n        _settings: settings,\n        _howl: howl,\n        play,\n        stop,\n        getIsPlaying,\n        getDuration,\n        unload\n    };\n};\nexport { createBleep };\n"],"mappings":"AAAA,SAASA,MAAM,EAAEC,IAAI,QAAQ,QAAQ;AACrC,MAAMC,WAAW,GAAG,CAACC,aAAa,EAAEC,cAAc,KAAK;EACnD,MAAM;IAAEC,QAAQ;IAAE,GAAGC;EAAS,CAAC,GAAG;IAC9B,GAAGH,aAAa;IAChB,GAAGC;EACP,CAAC;EACD;EACA;EACA;EACA;EACA,MAAMG,mBAAmB,GAAG,CAACP,MAAM,CAACQ,cAAc;EAClD,IAAIC,QAAQ,GAAGF,mBAAmB;EAClC,IAAIG,MAAM;EACV,MAAMC,IAAI,GAAG,IAAIV,IAAI,CAAC;IAClB,GAAGK,QAAQ;IACXM,QAAQ,EAAE,MAAM;MACZH,QAAQ,GAAG,KAAK;IACpB;EACJ,CAAC,CAAC;EACF;EACA;EACA;EACA;EACA,MAAMI,cAAc,GAAG,CAAC,CAAC;EACzB,MAAMC,IAAI,GAAIC,UAAU,IAAK;IACzB;IACA;IACA,IAAIJ,IAAI,CAACK,KAAK,EAAE,KAAK,UAAU,EAAE;MAC7BL,IAAI,CAACM,IAAI,EAAE;IACf;IACA;IACA;IACA;IACA;IACA,IAAIR,QAAQ,EAAE;MACV;IACJ;IACAI,cAAc,CAACE,UAAU,CAAC,GAAG,IAAI;IACjC;IACA;IACA,MAAMG,KAAK,GAAGP,IAAI,CAACG,IAAI,CAACJ,MAAM,CAAC;IAC/B;IACA;IACAA,MAAM,GAAGQ,KAAK,IAAIC,SAAS;EAC/B,CAAC;EACD,MAAMC,IAAI,GAAIL,UAAU,IAAK;IACzB,OAAOF,cAAc,CAACE,UAAU,CAAC,CAAC,CAAC;IACnC,MAAMM,eAAe,GAAG,CAACC,MAAM,CAACC,IAAI,CAACV,cAAc,CAAC,CAACW,MAAM;IAC3D,MAAMC,OAAO,GAAGnB,QAAQ,CAACoB,IAAI,GAAGL,eAAe,GAAG,IAAI;IACtD,IAAII,OAAO,IAAId,IAAI,CAACgB,OAAO,EAAE,EAAE;MAC3BhB,IAAI,CAACS,IAAI,EAAE;IACf;EACJ,CAAC;EACD,MAAMQ,YAAY,GAAG,MAAM;IACvB,OAAOjB,IAAI,CAACgB,OAAO,EAAE;EACzB,CAAC;EACD,MAAME,WAAW,GAAG,MAAM;IACtB,OAAOlB,IAAI,CAACmB,QAAQ,EAAE;EAC1B,CAAC;EACD,MAAMC,MAAM,GAAG,MAAM;IACjBpB,IAAI,CAACoB,MAAM,EAAE;EACjB,CAAC;EACD,OAAO;IACHC,SAAS,EAAE1B,QAAQ;IACnB2B,KAAK,EAAEtB,IAAI;IACXG,IAAI;IACJM,IAAI;IACJQ,YAAY;IACZC,WAAW;IACXE;EACJ,CAAC;AACL,CAAC;AACD,SAAS7B,WAAW"},"metadata":{},"sourceType":"module","externalDependencies":[]}